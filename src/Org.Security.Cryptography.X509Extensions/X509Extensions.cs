
using System;
using System.IO;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;

namespace Org.Security.Cryptography
{
    /// <summary>
    /// Encryption/Decryption helpers, that uses KeyEncryptionKey (KEK) and DataEncryptionKey (DEK) to encrypt/decrypt data streams.
    /// DEK encryption uses AsymmetricAlgorithm while encrypting actual data using the DEK uses SymmetricAlgorithm.
    /// The X509Certificate public/private key pair is used as KeyEncryptionKey (KEK).
    /// The key and IV randomly generated by the SymmetricAlgorithm is used as DataEncryptionKey (DEK).
    /// The DataEncryptionKey and the IV are unique for each call. 
    /// The encrypted version of DataEncryptionKey and the IV are written as header to output stream.
    /// Output stream structure: [DEK-Length][DEK][IV-Length][IV][EncryptedBytes]
    /// </summary>
    public static class X509Extensions
    {
        //...............................................................................
        #region About TripleDESCryptoServiceProvider, Microsoft says:
        //...............................................................................
        // A newer symmetric encryption algorithm, Advanced Encryption Standard (AES), is available. 
        // Consider using the Aes class and its derived classes instead of the TripleDES class. 
        // Use TripleDES only for compatibility with legacy applications and data.
        // const string DefaultDataEncryptionAlgorithm = "3DES";
        // const int DefaultDataEncryptionKeySize = 128;
        // const int DefaultDataEncryptionBlockSize = 64;

        #endregion

        const string DefaultDataEncryptionAlgorithm = "Aes";
        const int DefaultDataEncryptionKeySize = 256;
        const int DefaultDataEncryptionBlockSize = 128;

        /// <summary>
        /// Writes encrypted version of the data to the output stream.
        /// The PublicKey of the X509 certificate is used as KeyEncryptionKey (KEK).
        /// A randomly generated key and IV of the SymmetricAlgorithm is used as DataEncryptionKey (DEK).
        /// Writes the encrypted DEK, IV and the encrypted data to the outputstream.
        /// NOTE: The output stream will be closed, since the Encrypted stream will be closed/disposed.
        /// </summary>
        public static void EncryptUsingPublicKey(this X509Certificate2 x509WithPublicKey, Stream inputStream, Stream outputStream, string dataEncryptionAlgorithmName = DefaultDataEncryptionAlgorithm, int keySize = DefaultDataEncryptionKeySize, int blockSize = DefaultDataEncryptionBlockSize)
        {
            if (null == x509WithPublicKey) throw new ArgumentNullException(nameof(x509WithPublicKey));
            if (null == inputStream) throw new ArgumentNullException(nameof(inputStream));
            if (null == outputStream) throw new ArgumentNullException(nameof(outputStream));
            if (null == dataEncryptionAlgorithmName) throw new ArgumentNullException(nameof(dataEncryptionAlgorithmName));

            try
            {
                if (null == x509WithPublicKey.PublicKey) throw new Exception($"X509Certificate2.PublicKey was NULL. Cert: {x509WithPublicKey.Thumbprint}");
                if (null == x509WithPublicKey.PublicKey.Key) throw new Exception($"X509Certificate2.PublicKey.Key was NULL. Cert: {x509WithPublicKey.Thumbprint}");

                // IMP: We didn't create the Cert. DO NOT DISPOSE.
                // IMP: Disposing the AsymmetricAlgorithm will render the X509Certificate2 useless for subsequent use.
                AsymmetricAlgorithm keyEncryptionAlgorithm = x509WithPublicKey.PublicKey.Key;

                using (SymmetricAlgorithm dataEncryptionAlgorithm = SymmetricAlgorithm.Create(dataEncryptionAlgorithmName))
                {
                    if (null == dataEncryptionAlgorithm) throw new Exception($"SymmetricAlgorithm.Create('{dataEncryptionAlgorithmName}') returned NULL.");

                    // Set desired key and block size.
                    // This may throw an excepion on invalid key/block sizes.
                    dataEncryptionAlgorithm.KeySize = keySize;
                    dataEncryptionAlgorithm.BlockSize = blockSize;

                    // The DataEncryptionKey and IV.
                    byte[] dataEncryptionKey = dataEncryptionAlgorithm.Key ?? throw new Exception("dataEncryptionAlgorithm.Key was NULL.");
                    byte[] dataEncryptionIV = dataEncryptionAlgorithm.IV ?? throw new Exception("dataEncryptionAlgorithm.IV was NULL.");

                    // Encrypt the DEK using the X509 public key (KEK).
                    var keyFormatter = new RSAPKCS1KeyExchangeFormatter(keyEncryptionAlgorithm);
                    byte[] encryptedDataEncryptionKey = keyFormatter.CreateKeyExchange(dataEncryptionKey);

                    // Essential debug information...
                    MyTrace.Info(() => $"KEK: {keyEncryptionAlgorithm.GetType().Name} / {keyEncryptionAlgorithm.KeySize} bits / {x509WithPublicKey.Thumbprint}");
                    MyTrace.Info(() => $"DEK: {dataEncryptionAlgorithm.GetType().Name} / {dataEncryptionAlgorithm.KeySize} bits. / BlockSize: {dataEncryptionAlgorithm.BlockSize} bits.");

                    // Write the EncryptedDEK and the IV (length & bytes)
                    outputStream.WriteLengthAndBytes(encryptedDataEncryptionKey);
                    outputStream.WriteLengthAndBytes(dataEncryptionIV);

                    // Write encrypted data
                    using (var transform = dataEncryptionAlgorithm.CreateEncryptor())
                    using (var cryptoStream = new CryptoStream(outputStream, transform, CryptoStreamMode.Write))
                    {
                        int bufferSize = dataEncryptionAlgorithm.BlockSize;
                        inputStream.CopyTo(cryptoStream, bufferSize);
                    }
                }
            }
            catch (Exception err)
            {
                MyTrace.Error(err);
                throw;
            }
        }

        /// <summary>
        /// Writes decrypted version of the data to the output stream.
        /// Reads the encrypted DataEncryptionKey (DEK) and the IV from the input stream.
        /// The PrivateKey of the X509 certificate is used to decrypt the DataEncryptionKey.
        /// </summary>
        public static void DecryptUsingPrivateKey(this X509Certificate2 x509WithPrivateKey, Stream inputStream, Stream outputStream, string dataEncryptionAlgorithmName = DefaultDataEncryptionAlgorithm)
        {
            if (null == inputStream) throw new ArgumentNullException(nameof(inputStream));
            if (null == outputStream) throw new ArgumentNullException(nameof(outputStream));
            if (null == x509WithPrivateKey) throw new ArgumentNullException(nameof(x509WithPrivateKey));
            if (null == dataEncryptionAlgorithmName) throw new ArgumentNullException(nameof(dataEncryptionAlgorithmName));

            try
            {
                if (null == x509WithPrivateKey.PrivateKey) throw new Exception($"X509Certificate2.PrivateKey was NULL. Cert: {x509WithPrivateKey.Thumbprint}");

                // IMP: We didn't create the Cert. DO NOT DISPOSE.
                // IMP: Disposing the AsymmetricAlgorithm will render the X509Certificate2 useless for subsequent use.
                AsymmetricAlgorithm keyEncryptionAlgorithm = x509WithPrivateKey.PrivateKey;

                // Read the encrypted DataEncryptionKey and IV
                byte[] encryptedDataEncryptionKey = inputStream.ReadLengthAndBytes();
                byte[] dataEncryptionIV = inputStream.ReadLengthAndBytes();

                using (SymmetricAlgorithm dataEncryptionAlgorithm = SymmetricAlgorithm.Create(dataEncryptionAlgorithmName))
                {
                    if (null == dataEncryptionAlgorithm) throw new Exception($"SymmetricAlgorithm.Create('{dataEncryptionAlgorithmName}') returned NULL.");

                    // Decrypt the DataEncryptionKey
                    RSAPKCS1KeyExchangeDeformatter keyDeFormatter = new RSAPKCS1KeyExchangeDeformatter(keyEncryptionAlgorithm);
                    byte[] dataEncryptionKey = keyDeFormatter.DecryptKeyExchange(encryptedDataEncryptionKey);

                    dataEncryptionAlgorithm.Key = dataEncryptionKey;
                    dataEncryptionAlgorithm.IV = dataEncryptionIV;

                    // Debug information (Set Trace to warning or above for PRD)
                    MyTrace.Info(() => $"KEK: {keyEncryptionAlgorithm.GetType().Name} / {keyEncryptionAlgorithm.KeySize} bits / {x509WithPrivateKey.Thumbprint}");
                    MyTrace.Info(() => $"DEK: {dataEncryptionAlgorithm.GetType().Name} / {dataEncryptionAlgorithm.KeySize} bits. / BlockSize: {dataEncryptionAlgorithm.BlockSize} bits.");

                    // Decrypt the data.
                    using (var transform = dataEncryptionAlgorithm.CreateDecryptor())
                    using (var cryptoStream = new CryptoStream(inputStream, transform, CryptoStreamMode.Read))
                    {
                        int bufferSize = dataEncryptionAlgorithm.BlockSize;
                        cryptoStream.CopyTo(outputStream, bufferSize);
                    }
                }
            }
            catch (Exception err)
            {
                MyTrace.Error(err);
                throw;
            }
        }

        /// <summary>
        /// Copies content of input stream to the output stream.
        /// Using a single buffer of suggested buffer size.
        /// </summary>
        static void CopyTo(this Stream inputStream, Stream outputStream, int bufferSize)
        {
            if (null == inputStream) throw new ArgumentNullException(nameof(inputStream));
            if (null == outputStream) throw new ArgumentNullException(nameof(outputStream));
            if (bufferSize <= 0) throw new ArgumentException("Invalid buffer size; Must be > 0");

            byte[] buffer = new byte[bufferSize];
            int bytesRead = 0;
            do
            {
                bytesRead = inputStream.Read(buffer, 0, buffer.Length);
                if (bytesRead > 0) outputStream.Write(buffer, 0, bytesRead);
            }
            while (bytesRead > 0);
        }

        /// <summary>
        /// Writes four-byte-header that represents length of data, followed by the data itself.
        /// </summary>
        static void WriteLengthAndBytes(this Stream outputStream, byte[] bytes)
        {
            if (null == outputStream) throw new ArgumentNullException(nameof(outputStream));
            if (null == bytes) throw new ArgumentNullException(nameof(bytes));

            outputStream.WriteInt32(bytes.Length);
            outputStream.Write(bytes, 0, bytes.Length);
        }

        /// <summary>
        /// Reads four-byte-header which represents length of data, and reads the data.
        /// </summary>
        static byte[] ReadLengthAndBytes(this Stream inputStream)
        {
            if (null == inputStream) throw new ArgumentNullException(nameof(inputStream));

            // Read the length of data to read.
            int dataLength = inputStream.ReadInt32();

            // Read the data
            byte[] data = new byte[dataLength];
            var bytesRead = inputStream.Read(data, 0, data.Length);
            if (bytesRead != data.Length) throw new Exception($"Unexpected end of stream. Expecting {data.Length} bytes. Found {bytesRead} bytes.");

            return data;
        }

        /// <summary>
        /// Writes given Int32 value to the stream.
        /// </summary>
        static void WriteInt32(this Stream outputStream, Int32 value)
        {
            if (null == outputStream) throw new ArgumentNullException(nameof(outputStream));

            byte[] fourBytes = BitConverter.GetBytes(value);
            outputStream.Write(fourBytes, 0, 4);
        }

        /// <summary>
        /// Reads an Int32 value from the stream.
        /// </summary>
        static Int32 ReadInt32(this Stream inputStream)
        {
            if (null == inputStream) throw new ArgumentNullException(nameof(inputStream));

            byte[] fourBytes = new byte[4];
            int bytesRead = inputStream.Read(fourBytes, 0, 4);
            if (bytesRead != 4) throw new Exception($"Unexpected end of stream. Expecting 4 bytes. Found {bytesRead} bytes.");

            return BitConverter.ToInt32(fourBytes, startIndex: 0);
        }
    }
}

